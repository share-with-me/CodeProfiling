<?xml version="1.0"?><rats_output>
<stats>
<dbcount lang="perl">33</dbcount>
<dbcount lang="ruby">46</dbcount>
<dbcount lang="python">62</dbcount>
<dbcount lang="c">334</dbcount>
<dbcount lang="php">55</dbcount>
</stats>
<vulnerability>
  <severity>High</severity>
  <type>gettext</type>
  <message>
    Environment variables are highly untrustable input. They may be of any length, and contain any data. Do not make any assumptions regarding content or length. If at all possible avoid using them, and if it is necessary, sanitize them and truncate them to a reasonable length.  gettext() can utilize the LC_ALL or LC_MESSAGES environment variables.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>16</line>
    <line>21</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <message>
    Check to be sure that argument 2 passed to this function call will not
    copy more data than can be handled, resulting in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>16</line>
    <line>17</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>sprintf</type>
  <message>
    Check to be sure that the format string passed as argument 2 to this
    function call does not come from an untrusted source that could have added
    formatting characters that the code is not prepared to handle.
    Additionally, the format string could contain `%s' without precision that
    could result in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>20</line>
    <line>21</line>
    <line>22</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>sprintf</type>
  <message>
    Check to be sure that the non-constant format string passed as argument 2 
    to this function call does not come from an untrusted source that could
    have added formatting characters that the code is not prepared to handle.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>21</line>
    <line>22</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>printf</type>
  <message>
    Check to be sure that the non-constant format string passed as argument 1 
    to this function call does not come from an untrusted source that could
    have added formatting characters that the code is not prepared to handle.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>23</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>scanf</type>
  <message>
    Check to be sure that the format string passed as argument 2 to this
    function call does not come from an untrusted source that could have added
    formatting characters that the code is not prepared to handle.
    Additionally, the format string could contain `%s' without precision that
    could result in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>24</line>
    <line>25</line>
    <line>26</line>
    <line>27</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>gets</type>
  <message>
    Gets is unsafe!! No bounds checking is performed, buffer
      is easily overflowable by user. Use fgets(buf, size, stdin) instead.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>28</line>
    <line>31</line>
    <line>32</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>syslog</type>
  <message>
    Truncate all input strings to a reasonable length 
before passing them to this function
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>35</line>
    <line>36</line>
    <line>38</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>fixed size global buffer</type>
  <message>
    Extra care should be taken to ensure that character arrays that are
    allocated on the stack are used safely.  They are prime targets for
    buffer overflow attacks.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>45</line>
    <line>46</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <message>
    Check to be sure that argument 2 passed to this function call will not
    copy more data than can be handled, resulting in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>49</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <message>
    Check to be sure that argument 2 passed to this function call will not
    copy more data than can be handled, resulting in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>52</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>strncat</type>
  <message>
    Consider using strlcat() instead.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>55</line>
    <line>56</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <message>
    Check to be sure that argument 1 passed to this function call will not
    copy more data than can be handled, resulting in a buffer overflow.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>55</line>
    <line>56</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>CreateProcess</type>
  <message>
    Many program execution commands under Windows will search
the path for a program if you do not explicitly specify a full path to the 
file. This can allow trojans to be executed instead.  Also, be sure to
specify a file extension, since otherwise multiple extensions will be tried
by the operating system, providing another opportunity for trojans.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>75</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>High</severity>
  <type>getopt_long</type>
  <message>
    Truncate all input strings to a reasonable length 
before passing them to this function
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>91</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Medium</severity>
  <type>SetSecurityDescriptorDacl</type>
  <message>
    If the third argument, pDacl, is NULL there is no protection from attack.  As an example, an attacker could set a Deny All to Everyone ACE on such an object.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>73</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>memcpy</type>
  <message>
    Double check that your buffer is as big as you specify.
When using functions that accept a number n of bytes to copy, such as 
strncpy, be aware that if the dest buffer size = n it may not NULL-terminate 
the string.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>50</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>CopyMemory</type>
  <message>
    Double check that your buffer is as big as you specify.
When using functions that accept a number n of bytes to copy, such as 
strncpy, be aware that if the dest buffer size = n it may not NULL-terminate 
the string.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>51</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>strncpy</type>
  <message>
    Double check that your buffer is as big as you specify.
When using functions that accept a number n of bytes to copy, such as 
strncpy, be aware that if the dest buffer size = n it may not NULL-terminate 
the string. Also, consider using strlcpy() instead, if it is avaialable to you.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>53</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>_tcsncpy</type>
  <message>
    Double check that your buffer is as big as you specify.
When using functions that accept a number n of bytes to copy, such as 
strncpy, be aware that if the dest buffer size = n it may not NULL-terminate 
the string.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>54</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>_tcsncat</type>
  <message>
    Double check that your buffer is as big as you specify.
When using functions that accept a number n of bytes to copy, such as 
strncpy, be aware that if the dest buffer size = n it may not NULL-terminate 
the string.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>57</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>strlen</type>
  <message>
    This function does not properly handle non-NULL terminated
strings.  This does not result in exploitable code, but can lead to access 
violations.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>58</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>MultiByteToWideChar</type>
  <message>
    The last argument is the number of wide chars, not the number of bytes.  Getting this wrong can cause a buffer overflow since you will indicate that the buffer is twice the size it actually is.  Don't forget about NULL termination.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>60</line>
    <line>62</line>
    <line>64</line>
    <line>66</line>
  </file>
</vulnerability>
<vulnerability>
  <severity>Low</severity>
  <type>fixed size local buffer</type>
  <message>
    A potential race condition vulnerability exists here.  Normally a call
    to this function is vulnerable only when a match check precedes it.  No
    check was detected, however one could still exist that could not be
    detected.
  </message>
  <file>
    <name>test_flaw.c</name>
    <line>97</line>
  </file>
</vulnerability>
<timing>
<total_lines>118</total_lines>
<total_time>0.000333</total_time>
<lines_per_second>354354</lines_per_second>
</timing>
</rats_output>
